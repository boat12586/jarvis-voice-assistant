#!/usr/bin/env python3
"""
ü§ñ JARVIS Complete Voice System
‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏° Real-time Conversation, Thai Processing, Memory ‡πÅ‡∏•‡∏∞ Wake Word
"""

import logging
import sys
import time
import threading
from pathlib import Path
from typing import Dict, Any, Optional

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / "src"))

# Import JARVIS components
try:
    from voice.realtime_conversation import RealTimeVoiceConversation, VoiceMessage
    from voice.advanced_thai_processor import AdvancedThaiProcessor
    from voice.simple_wake_word import SimpleWakeWordDetector
    from features.advanced_conversation_memory import AdvancedConversationMemory
    from ai.llm_engine import LLMEngine
    from system.config_manager_v2 import ConfigurationManager
    COMPONENTS_AVAILABLE = True
except ImportError as e:
    COMPONENTS_AVAILABLE = False
    logging.error(f"JARVIS components not available: {e}")


class JarvisVoiceSystem:
    """‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô‡∏Ç‡∏≠‡∏á JARVIS"""
    
    def __init__(self, config_path: str = "config/default_config.yaml"):
        self.logger = logging.getLogger(__name__)
        
        # Load configuration  
        self.config_path = config_path
        self.config = {}
        
        # Use simple config loading first
        try:
            import yaml
            if Path(config_path).exists():
                with open(config_path, 'r') as f:
                    self.config = yaml.safe_load(f) or {}
                self.logger.info("‚úÖ Configuration loaded successfully")
            else:
                self.logger.warning(f"‚ö†Ô∏è Config file not found: {config_path}")
                self.config = {}
        except Exception as e:
            self.logger.error(f"‚ùå Configuration loading failed: {e}")
            self.config = {}
        
        # Initialize components
        self.conversation_system = None
        self.thai_processor = None
        self.wake_word_detector = None
        self.memory_system = None
        self.llm_engine = None
        
        # System state
        self.is_active = False
        self.current_mode = "idle"  # idle, listening, processing, responding
        self.conversation_active = False
        
        # Statistics
        self.stats = {
            "total_conversations": 0,
            "wake_words_detected": 0,
            "responses_generated": 0,
            "thai_interactions": 0,
            "english_interactions": 0,
            "start_time": time.time()
        }
        
        if COMPONENTS_AVAILABLE:
            self._initialize_components()
        else:
            self.logger.error("‚ùå Cannot initialize - components not available")
    
    def _initialize_components(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        self.logger.info("üöÄ Initializing JARVIS Voice System components...")
        
        try:
            # Initialize Thai processor
            self.thai_processor = AdvancedThaiProcessor(self.config.get('thai', {}))
            self.logger.info("‚úÖ Thai processor ready")
            
            # Initialize conversation memory
            self.memory_system = AdvancedConversationMemory(
                config=self.config.get('memory', {}),
                data_dir="data/conversation_memory"
            )
            self.logger.info("‚úÖ Memory system ready")
            
            # Initialize real-time conversation
            conversation_config = self.config.get('voice', {})
            conversation_config.update({
                'whisper_model': 'tiny',  # Fast for real-time
                'sample_rate': 16000,
                'silence_threshold': 0.01,
                'silence_duration': 2.0
            })
            
            self.conversation_system = RealTimeVoiceConversation(conversation_config)
            
            # Set up conversation callbacks
            self.conversation_system.on_speech_detected = self._on_speech_detected
            self.conversation_system.on_text_recognized = self._on_text_recognized
            self.conversation_system.on_response_generated = self._on_response_generated
            
            self.logger.info("‚úÖ Real-time conversation ready")
            
            # Initialize wake word detector
            wake_word_config = {
                'whisper_model': 'tiny',
                'confidence_threshold': 0.7,
                'sample_rate': 16000
            }
            
            self.wake_word_detector = SimpleWakeWordDetector(wake_word_config)
            
            # Set up wake word callbacks
            self.wake_word_detector.on_wake_word = self._on_wake_word_detected
            self.wake_word_detector.on_listening_started = self._on_wake_listening_started
            self.wake_word_detector.on_listening_stopped = self._on_wake_listening_stopped
            
            self.logger.info("‚úÖ Wake word detector ready")
            
            # Initialize AI with fallback support
            try:
                from ai.deepseek_integration import DeepSeekR1
                self.llm_engine = DeepSeekR1(config_path=str(Path(__file__).parent / "config" / "default_config.yaml"))
                model_info = self.llm_engine.get_model_info()
                self.logger.info(f"‚úÖ AI system ready: {model_info['name']} ({model_info['status']})")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è AI engine not ready: {e}")
                # Create fallback AI directly
                try:
                    from ai.fallback_ai import FallbackAI
                    self.llm_engine = FallbackAI()
                    self.logger.info("‚úÖ Fallback AI system ready")
                except Exception as e2:
                    self.logger.error(f"Fallback AI also failed: {e2}")
                    self.llm_engine = None
            
            self.logger.info("üéâ All JARVIS components initialized successfully!")
            
        except Exception as e:
            self.logger.error(f"‚ùå Component initialization failed: {e}")
    
    def start_system(self) -> bool:
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö JARVIS"""
        if not COMPONENTS_AVAILABLE:
            self.logger.error("‚ùå Cannot start - components not available")
            return False
        
        if self.is_active:
            self.logger.warning("‚ö†Ô∏è System already active")
            return True
        
        self.logger.info("üöÄ Starting JARVIS Voice System...")
        
        try:
            # Start wake word detection
            if self.wake_word_detector:
                if not self.wake_word_detector.start_listening():
                    self.logger.error("‚ùå Failed to start wake word detection")
                    return False
            
            self.is_active = True
            self.current_mode = "listening"
            self.stats["start_time"] = time.time()
            
            self.logger.info("‚úÖ JARVIS Voice System is now active!")
            self.logger.info("üéôÔ∏è Say 'Hey JARVIS' to start a conversation")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå System startup failed: {e}")
            return False
    
    def stop_system(self):
        """‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö JARVIS"""
        if not self.is_active:
            return
        
        self.logger.info("üõë Stopping JARVIS Voice System...")
        
        try:
            # Stop conversation if active
            if self.conversation_active and self.conversation_system:
                self.conversation_system.stop_conversation()
                self.conversation_active = False
            
            # Stop wake word detection
            if self.wake_word_detector:
                self.wake_word_detector.stop_listening()
            
            self.is_active = False
            self.current_mode = "idle"
            
            self.logger.info("‚úÖ JARVIS Voice System stopped")
            
        except Exception as e:
            self.logger.error(f"‚ùå System shutdown error: {e}")
    
    def _on_wake_word_detected(self, text: str, confidence: float):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Ñ‡∏≥‡∏õ‡∏•‡∏∏‡∏Å"""
        self.logger.info(f"üö® Wake word detected: '{text}' (confidence: {confidence:.2f})")
        self.stats["wake_words_detected"] += 1
        
        # Start conversation
        self._start_conversation()
    
    def _on_wake_listening_started(self):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏õ‡∏•‡∏∏‡∏Å"""
        self.logger.debug("üëÇ Listening for wake words...")
    
    def _on_wake_listening_stopped(self):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏õ‡∏•‡∏∏‡∏Å"""
        self.logger.debug("üîá Wake word listening stopped")
    
    def _start_conversation(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤"""
        if self.conversation_active:
            self.logger.warning("‚ö†Ô∏è Conversation already active")
            return
        
        self.logger.info("üí¨ Starting conversation...")
        self.current_mode = "processing"
        
        # Stop wake word detection temporarily
        if self.wake_word_detector:
            self.wake_word_detector.stop_listening()
        
        # Start conversation system
        if self.conversation_system:
            if self.conversation_system.start_conversation():
                self.conversation_active = True
                self.current_mode = "listening"
                self.stats["total_conversations"] += 1
                
                # Auto-timeout conversation after 30 seconds of silence
                threading.Timer(30.0, self._timeout_conversation).start()
                
                self.logger.info("‚úÖ Conversation started! Speak now...")
            else:
                self.logger.error("‚ùå Failed to start conversation")
                self._restart_wake_detection()
    
    def _timeout_conversation(self):
        """‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤"""
        if self.conversation_active:
            self.logger.info("‚è∞ Conversation timeout")
            self._end_conversation()
    
    def _end_conversation(self):
        """‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏ô‡∏ó‡∏ô‡∏≤"""
        if not self.conversation_active:
            return
        
        self.logger.info("üëã Ending conversation...")
        
        # Stop conversation system
        if self.conversation_system:
            self.conversation_system.stop_conversation()
        
        self.conversation_active = False
        self.current_mode = "listening"
        
        # Restart wake word detection
        self._restart_wake_detection()
    
    def _restart_wake_detection(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏õ‡∏•‡∏∏‡∏Å‡πÉ‡∏´‡∏°‡πà"""
        if self.wake_word_detector and self.is_active:
            time.sleep(1)  # Brief pause
            self.wake_word_detector.start_listening()
    
    def _on_speech_detected(self):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏û‡∏π‡∏î"""
        self.logger.debug("üé§ Speech detected...")
        self.current_mode = "listening"
    
    def _on_text_recognized(self, message: VoiceMessage):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏π‡πâ‡∏à‡∏≥‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏î‡πâ"""
        self.logger.info(f"üìù User said ({message.language}): {message.text}")
        self.current_mode = "processing"
        
        # Update language statistics
        if message.language == 'th':
            self.stats["thai_interactions"] += 1
        else:
            self.stats["english_interactions"] += 1
        
        # Process with Thai processor if Thai
        if message.language == 'th' and self.thai_processor:
            thai_result = self.thai_processor.process_text(message.text)
            context = self.thai_processor.generate_thai_response_context(
                message.text, thai_result.intent
            )
            self.logger.debug(f"üáπüá≠ Thai context: {context}")
        
        # Generate AI response
        self._generate_response(message)
    
    def _generate_response(self, message: VoiceMessage):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á"""
        try:
            # Get conversation context from memory
            if self.memory_system:
                context_turns = self.memory_system.get_relevant_context(
                    message.text, max_turns=3
                )
                context_text = " ".join([turn.user_input for turn in context_turns])
            else:
                context_text = ""
            
            # Generate response using AI engine
            if self.llm_engine:
                # Check if it's the new AI system or old format
                if hasattr(self.llm_engine, 'generate_response'):
                    # New AI system (DeepSeek or Fallback)
                    context_data = {
                        'conversation_history': [
                            {'user': turn.user_input, 'assistant': turn.ai_response}
                            for turn in (context_turns if self.memory_system else [])
                        ]
                    }
                    ai_response = self.llm_engine.generate_response(message.text, context_data)
                else:
                    # Old AI system format
                    prompt = f"Context: {context_text}\nUser: {message.text}\nJARVIS:"
                    response = self.llm_engine.process_query(
                        prompt, 
                        language=message.language
                    )
                    ai_response = response.get('response', '') if response else ''
                
                if ai_response:
                    
                    # Process Thai response if needed
                    if message.language == 'th' and self.thai_processor:
                        thai_context = {'recommended_particle': '‡∏Ñ‡∏£‡∏±‡∏ö'}
                        ai_response = self.thai_processor.format_thai_response(
                            ai_response, thai_context
                        )
                    
                    # Add to conversation memory
                    if self.memory_system:
                        self.memory_system.add_conversation_turn(
                            user_input=message.text,
                            ai_response=ai_response,
                            user_language=message.language,
                            intent="response"
                        )
                    
                    # Add to conversation system
                    if self.conversation_system:
                        self.conversation_system.add_jarvis_response(
                            ai_response, message.language
                        )
                    
                    self.stats["responses_generated"] += 1
                    self.logger.info(f"ü§ñ JARVIS responds: {ai_response}")
                    
                else:
                    self.logger.warning("‚ö†Ô∏è No AI response generated")
            
            else:
                # Fallback response
                fallback_responses = {
                    'en': "I understand. How can I help you further?",
                    'th': "‡∏ú‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏£‡∏±‡∏ö ‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏≠‡∏µ‡∏Å‡πÑ‡∏´‡∏°‡∏Ñ‡∏£‡∏±‡∏ö"
                }
                
                response = fallback_responses.get(message.language, fallback_responses['en'])
                
                if self.conversation_system:
                    self.conversation_system.add_jarvis_response(response, message.language)
                
                self.logger.info(f"ü§ñ JARVIS (fallback): {response}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Response generation failed: {e}")
        
        finally:
            self.current_mode = "listening"
    
    def _on_response_generated(self, message: VoiceMessage):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à"""
        self.logger.debug(f"‚úÖ Response ready: {message.text}")
        self.current_mode = "responding"
    
    def get_system_status(self) -> Dict[str, Any]:
        """‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö"""
        uptime = time.time() - self.stats.get("start_time", time.time())
        
        status = {
            "system_active": self.is_active,
            "current_mode": self.current_mode,
            "conversation_active": self.conversation_active,
            "components": {
                "conversation_system": self.conversation_system is not None,
                "thai_processor": self.thai_processor is not None,
                "wake_word_detector": self.wake_word_detector is not None,
                "memory_system": self.memory_system is not None,
                "llm_engine": self.llm_engine is not None
            },
            "statistics": self.stats.copy(),
            "uptime_seconds": uptime
        }
        
        return status
    
    def process_text_command(self, text: str, language: str = "en") -> str:
        """‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö)"""
        if not self.is_active:
            return "System not active"
        
        # Create mock voice message
        message = VoiceMessage(
            message_id="test",
            text=text,
            language=language,
            timestamp=time.time(),
            speaker="user"
        )
        
        # Process normally
        self._on_text_recognized(message)
        
        return "Command processed"


def test_complete_voice_system():
    """‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô"""
    print("üß™ Testing JARVIS Complete Voice System...")
    
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create system
    jarvis = JarvisVoiceSystem()
    
    # Check system status
    print(f"\nüìä Initial status: {jarvis.get_system_status()}")
    
    # Start system
    print(f"\nüöÄ Starting system...")
    if jarvis.start_system():
        print("‚úÖ System started successfully!")
        
        # Test text commands
        print(f"\nüí¨ Testing text commands...")
        test_commands = [
            ("Hello JARVIS", "en"),
            ("What time is it?", "en"),
            ("‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö", "th"),
            ("‡∏ä‡πà‡∏ß‡∏¢‡∏ö‡∏≠‡∏Å‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö", "th")
        ]
        
        for text, lang in test_commands:
            print(f"   Testing: {text} ({lang})")
            jarvis.process_text_command(text, lang)
            time.sleep(1)  # Brief pause between commands
        
        # Show final status
        print(f"\nüìä Final status: {jarvis.get_system_status()}")
        
        # Stop system
        time.sleep(2)
        print(f"\nüõë Stopping system...")
        jarvis.stop_system()
        
    else:
        print("‚ùå Failed to start system")
    
    print("\n‚úÖ Complete voice system test finished!")


if __name__ == "__main__":
    test_complete_voice_system()